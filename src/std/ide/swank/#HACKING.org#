#+TITLE: SLIME/SWANK: Hacking Gerbil as a LISP

This is another way to sneak my literate =.org= files into the master
branch.

Here's the thing: common lisp has a whole bunch of things that I like
and gerbil should have. Now, with =SLIME: The Superior Lisp
Interaction Mode for Emacs= there's a GUI/Protocol that uses those
things.

Because of that I can use SLIME to figure out a bunch of Gerbil things
that otherwise may be set aside, And, teach myself about gerbil by
trying to make CL things work!

* The =:debug= and =:debug-activate= responses

Emacs wants certain things for the =:debug='er.

Gerbil has a way to store the "continuation" of an error.

So, [[file:~/src/gerbil-19-rc/src/gambit/lib/_repl.scm::(define-prim (##display-continuation-backtrace][##display-continuation-backtrace]] is what the REPL uses.





* The =*slime-events*= buffer

In emacs when using =SLIME= there's a buffer called =*slime-events*=
that really helps for seeing how emacs interacts with what it thinks
is Common Lisp for the most part.

So looking in that buffer we can see the back and for and re-create
it.

#+begin_src emacs-lisp
  (setq inferior-lisp-program "/opt/homebrew/bin/sbcl")
#+end_src


The starting steps (from emacs) seem to be a bunch of =:emacs-rex= forms:

 - swank:connection-info
 - swank:swank-require
 - swank:init-presentations
 - swank-repl:create-repl

As luck would have it the code is structured that way and [[file:~/me/src/gerbil-19-rc/src/std/ide/swank/handlers.ss][handlers.ss]]
contains a bunch of code that handles exactly those.



