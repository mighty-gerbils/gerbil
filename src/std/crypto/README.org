#+TITLE: Crypto with libcrypto
#+OPTIONS: toc:nil

* Table of Contents
:PROPERTIES:
:TOC:      :include siblings :depth 4 :ignore (this)
:CUSTOM_ID: table-of-contents
:END:
:CONTENTS:
- [[#tutorial-rsa-or-hmac-signature][Tutorial: RSA or HMAC Signature]]
  - [[#crypto-signing-and-verifying][Crypto: Signing and Verifying]]
    - [[#jwt-the-reasoning-or-overview][JWT: The reasoning or overview]]
    - [[#rs256-signature][RS256 signature]]
      - [[#private-key][Private key]]
      - [[#signing-with-our-private-key][Signing with our Private Key]]
      - [[#verify-with-a-public-key][Verify with a Public Key]]
    - [[#hs256-signature][HS256 signature]]
      - [[#validation][Validation]]
  - [[#reference-documents][Reference Documents]]
- [[#reference][Reference]]
- [[#thest-fole][Thest Fole]]
:END:

* Tutorial: RSA or HMAC Signature
:PROPERTIES:
:EXPORT_FILE_NAME: ../../../doc/tutorials/crypto.md
:CUSTOM_ID: tutorial-rsa-or-hmac-signature
:END:
** Crypto: Signing and Verifying
:PROPERTIES:
:CUSTOM_ID: crypto-signing-and-verifying
:END:

#+BEGIN_EXPORT markdown
[This file is weaved from src/std/crypto/README.org]: #
[Editing it here will be overwritten by doc/build.sh]: # 
[In other words, edit the org file, not the .md]: # 
#+END_EXPORT

*** JWT: The reasoning or overview
:PROPERTIES:
:CUSTOM_ID: jwt-the-reasoning-or-overview
:END:

#+begin_quote
JSON Web Token (JWT) is a compact, URL-safe means of representing
claims to be transferred between two parties.  The claims in a JWT are
encoded as a JSON object ...
--[[https://datatracker.ietf.org/doc/html/rfc7519][RFC7519]]
#+end_quote

I need RSA in order to perform the =RS256= algorithm, an asymmetric
algorithm that uses a private key to sign a =JSON Web Token= (JWT) and
a public key to verify that signature.

Alternatively a JWT can be =HS256= .We'll get into that as well.
along with those an *ECDSA* algo is outlined in the [[https://datatracker.ietf.org/doc/html/rfc7519][RFC7519]]
specification.

To start let's import the right things.

#+begin_src scheme
  > (import :std/crypto :std/text/base64 :std/format)
#+end_src


*** =RS256= signature
:PROPERTIES:
:CUSTOM_ID: rs256-signature
:END:

What that means is that there a string =header.payload.signature= that
when decoded gives us a verifed object of somekind.

#+begin_src scheme :noweb-ref test-tutorial
  > (def token "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJhdWQiOiJodHRwczovL2lkZW50aXR5dG9vbGtpdC5nb29nbGVhcGlzLmNvbS9nb29nbGUuaWRlbnRpdHkuaWRlbnRpdHl0b29sa2l0LnYxLklkZW50aXR5VG9vbGtpdCIsImlhdCI6MTc1MjAxNzc2NSwiZXhwIjoxNzUyMDIxMzY1LCJpc3MiOiJmaXJlYmFzZS1hZG1pbnNkay1mYnN2Y0BlbGVjdHJvbmljLWNsYWltcy1tYW5hZ2VyLmlhbS5nc2VydmljZWFjY291bnQuY29tIiwic3ViIjoiZmlyZWJhc2UtYWRtaW5zZGstZmJzdmNAZWxlY3Ryb25pYy1jbGFpbXMtbWFuYWdlci5pYW0uZ3NlcnZpY2VhY2NvdW50LmNvbSIsInVpZCI6IjEifQ.XEBUFxgXvN0etkU1Fd4q7B-uqAVtlkJQOwG_dvj1osxvk6nnnByTO3BTgQgILXNhkPzePh9-LCZc_70VYGbodnzK7VxwjHas5Kg9LXueSdkdXDXwzdB2b1hPoXg95BVBe5iOou5j6g9PlRfrjkL05MIKE9dKuZl8n3Am11LUTijRyc20nWSwS86OmElkiU_XUD_O_r_CyygAUdNxIYkpWZVcbKsFaZpc9rA9Lj8DDLH-l7EeBkywv1Oi7dKd-9HxIYB8vVnp3txNhM6egP293YY9OqKDvOB6lvJ7mKaPTWbpY3PDh6XU4I5HUHKmU8bRReO0ZkPyy8t6oi3HVx_KoQ")
  > (defvalues (header payload signature) (apply values (string-split token #\.)))
#+end_src

According to the RFC all of those are =BASE64URL= encoded. Let us make
a =STRING= from it.

#+begin_src scheme :noweb-ref test-tutorial
  > (def (BYTES b64) (base64-string->u8vector b64 urlsafe?: #t))
  > (def (STRING b64) (utf8->string (BYTES b64)))
  > (STRING header)
  "{\"alg\":\"RS256\",\"typ\":\"JWT\"}"
  > (def (BASE64URL thing)
      (let ((u8 (if (u8vector? thing) thing (string->utf8 thing))))
        (u8vector->base64-string u8 urlsafe?: #t padding?: #f)))
  > (string=? header (BASE64URL (STRING header)))
  #t
#+end_src

The =alg= is =RS256= according to the *JSON* string in =header=. That
means the =signature= is a =sha256= signed digest of =header.payload= with an
=RSA= private key.

**** Private key
:PROPERTIES:
:CUSTOM_ID: private-key
:END:

In this case the imported =pkey-text= is a =PEM= with ="PrivateKeyInfo"= style
like outlined in [[https://datatracker.ietf.org/doc/html/rfc5208][RFC5208]].

#+begin_src scheme :noweb-ref test-tutorial
  > (def pkey-text "-----BEGIN PRIVATE KEY-----\nMIIEvAIBADANBgkqhkiG9w0BAQEFAASCBKYwggSiAgEAAoIBAQDT0U3Pw6EkTaQO\nQFBkcMsTEBeyBibv5NvBvevWvVCF1IN0j1hz3gsudOHbe2Uo9Ncm4HxK7QFrZsh9\nHZcFGALYyGRCqPX2RK/Zg66yqh0rdQdzhTr6JNDI2q63kxfaCzXS6ZIAMJ7XzMT0\nNl+O5V5JK8EO+MegvRrq1lgxBP8OGGhC2G+yC/uilZ43gtCZKioa2uZba0nWa4hX\ngH/DMmNeasLTFFDMcikabDtZSKsxtVa8NIZ0YgpUQkaAMf73vjcBHHKocytFJOBR\nU/uwKUVtkwhDYvAVLJXITIJe91UyJ+57uIEBeEbIGeBEfzrp9SVuwYyIvwr84WHe\n/NMkjTErAgMBAAECgf8LywrYJ7drrMW2YoE1RPEnc1UxhUQWwLzVRsytyU2ZeQgA\nh6Qq6epy9oNaMad/Kj00HSBQHD8UPxDMoK+Q+x1cAcw5eNumnPc0HMVcaQhRVCBu\nLobB/DbO3Wteh1itCKmbEusMZ3NmmmwTqxSS/GrGyWSyKThh1u0A1mX0sdKE3VlU\nkzJsX+WKDENraG7RKXh89d98Vq7bjeSHW6AJr+i16XXgM68obFSpY6EDxz5NtTOt\nJEllJMCLKIlaHLDz08/nZXRvmfEFYjf6+Z2CsffNXUjoi1ECWjEpUN74yPR4C/Rx\nYDIyObg8LIQXrGGXmL1t10DYV2VDVecV+V3hTj0CgYEA8Y8VdUf9Si0mLuxicTj1\nflUKhr/2hAfOvy3KOH74kR4iiC1rBZToFc35xzGeOGuVrF2OVyZrUTvhDFdz8MZ7\nrL1wjadoaiiYIAgL5gMFB846Qhm0gRSSIPzPesYI6oid3vIaQ/yCNwtdmcrUqoyQ\n/uPV/YmrOJy9JVc0P9R2kM0CgYEA4HsL9ph5JJo8g7Rl2eCK8M2VK9vEUK+ka01U\nz9hVXfFkEEZCSF7H3CAk7H3jKKTx2ZXw6G60v+FsRHhL6oLqZgmUMMsVeDydNKyr\nIkw+wGj56JFJXFDYYyvMOOU0Tz4YM0vubrGUycTx9tDE7ZBKAijIrT8J5sa0rcoG\nqFvr6dcCgYEAiWpeSKO1YZchm5v5vHMspLt4C4P0ltNiN7uyyETi3psIBfPgaAJ3\nrL/KEhkV6v643J80NDu03Td1JPIzEIu5G2GBP/Q2H/4L3Fz3d9fL6s7UsXmyB6RO\nJNnspek2dUVWmdecPYTOBsY+bxjFtmfUrEusFllUwBXaO/3JyW3yLRkCgYARvUeN\nvjDclp+vnMLru9Xe/7AJHj3eTnME08CfCC5+1QOeUZ8NTwgmOhgQ5EXeQWKnWjUG\neTEpdKv0oTkGmD/jvmAKlxHkRY36yqZfeH0BAYq2OTz94ZmoBJ8H4/0FQhfxfc+i\nyb/DTh/87DSTvXJLx2NMZY3nwc4naa6rAVCcUwKBgQDW4QP3cPiOpyNUlws0D98L\nAvTJxS1GW4z6jkAfcpArQ9FF5cDva4JkEzjFDSMj69KG0rCFzmbSbAKMUGcne8lh\nNzJ15SNHJ6tBLGsllB0vqv7SWWj4kEWC7snXcNETaCvVzUbV0boQZAcJ7gOSweWw\nErJ9eO6qLxw64/e2dwwDHA==\n-----END PRIVATE KEY-----\n")
#+end_src

Crypto works with bytes, not with strings so we'll convert it.
#+begin_src scheme :noweb-ref test-tutorial
  > (def pkey-bytes (string->utf8 pkey-text))
#+end_src

Using that it's time to create a =pkey= using =:std/crypto='s
=(bytes->pkey type bytes)= with the type as =#f= because it's actually
hidden in the key text. Have a look at [[https://cons.io/reference/std/crypto.html#bytes-to-private-key][the documentation]] for more
options.

#+begin_src scheme :noweb-ref test-tutorial
  > (def pkey (bytes->private-key #f pkey-bytes))
  > (pkey? pkey)
  #t
#+end_src

How do we know it's an =RSA= key? Easy!

The first way is to check the =pkey-type=.

#+begin_src scheme :noweb-ref test-tutorial
  > (pkey-type pkey)
  "RSA"
#+end_src

The other easier way is to ask if the =pkey-is-a?=. Some types inherit
other types so that can make a difference as to what is what.

#+begin_src scheme :noweb-ref test-tutorial
  > (pkey-is-a? pkey "RSA")
  #t
#+end_src

Because it's a =PEM= with =PrivateKeyInfo= as the format we can
recreate that string and, yup, it's the same.

#+begin_src scheme :noweb-ref test-tutorial
  > (def pkey-out-bytes
      (private-key->bytes pkey format: "PEM" structure: "PrivateKeyInfo"))
  > (string=? (utf8->string pkey-out-bytes) pkey-text)
  #t
#+end_src

**** Signing with our Private Key
:PROPERTIES:
:CUSTOM_ID: signing-with-our-private-key
:END:

As mentioned previously the =signing-input= for the signature is
=header.payload=.

#+begin_src scheme :noweb-ref test-tutorial
  > (def signing-input (string->utf8 (format "~a.~a" header payload)))
#+end_src

The =signature-output= is a signing digest of that using our =pkey=
with a =model: 'sha256=.

#+begin_src scheme :noweb-ref test-tutorial
  > (def signing-output (digest-sign pkey signing-input model: 'sha256))
#+end_src

So a =BASE64URL= encoding of that should match our initial test
signature and that means we've come full circle and can sign out own
*JWT*'s!

#+begin_src scheme :noweb-ref test-tutorial
  > (string=? signature (BASE64URL signing-output))
  #t
#+end_src

**** Verify with a Public Key
:PROPERTIES:
:CUSTOM_ID: verify-with-a-public-key
:END:

Signatures are verified using [[https://cons.io/reference/std/crypto.html#digest-verify][digest-verify]]. Using the same key we
encrypted with shows it.

#+begin_src scheme :noweb-ref test-tutorial
  > (digest-verify pkey signing-output signing-input model: 'sha256)
  #t
#+end_src

One of the reasons behind the whole Private/Public key architecture is
to give a public key that can verify this was signed using the private
key thereof.

Making a Public from a Private is easy. We use [[https://cons.io/reference/std/crypto.html#public-key-to-bytes][public-key->bytes]] with
our =pkey=. We'll use the =SubjectPublicKeyInfo= from [[https://datatracker.ietf.org/doc/html/rfc5280][RFC5280]]

#+begin_src scheme :noweb-ref test-tutorial
  > (def pubkey-bytes
      (public-key->bytes
       pkey format: "PEM" structure: "SubjectPublicKeyInfo"))
  > (def pubkey-string (utf8->string pubkey-bytes))
#+end_src

That gives us a short =-----BEGIN PUBLIC KEY-----= "file" that matches
our private key.

#+begin_src scheme :noweb-ref test-tutorial
  > (call-with-input-string pubkey-string read-line)
  "-----BEGIN PUBLIC KEY-----"
#+end_src

Making a =pkey?= with it is then simple.

#+begin_src scheme :noweb-ref test-tutorial
  > (def pubkey (bytes->public-key #f pubkey-bytes))
  > (pkey? pubkey)
  #t
#+end_src

We can see there is no private key.

#+begin_src scheme :noweb-ref test-tutorial
  > (private-key->bytes pubkey)
  #u8()
#+end_src

But the public key is the same as our one generated from the private
side.

#+begin_src scheme :noweb-ref test-tutorial
  > (equal? pubkey-bytes
     (public-key->bytes pubkey format: "PEM" structure: "SubjectPublicKeyInfo"))
  #t
#+end_src

And that means we can use it to verify.

#+begin_src scheme :noweb-ref test-tutorial
  > (digest-verify pubkey signing-output signing-input model: 'sha256)
  #t
#+end_src



*** =HS256= signature
:PROPERTIES:
:CUSTOM_ID: hs256-signature
:END:

Another way to encode a JWT signature is with =HMAC=. Here's an
example from [[https://www.rfc-editor.org/rfc/rfc7515.html#appendix-A.1.1][RFC7515]].

#+begin_src scheme :noweb-ref test-tutorial
  > (def hmac-token "eyJ0eXAiOiJKV1QiLA0KICJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJqb2UiLA0KICJleHAiOjEzMDA4MTkzODAsDQogImh0dHA6Ly9leGFtcGxlLmNvbS9pc19yb290Ijp0cnVlfQ.dBjftJeZ4CVP-mB92K27uhbUJU1p1r_wW1gFWFOEjXk")
  > (defvalues (hmac-header hmac-payload hmac-signature)
      (apply values (string-split hmac-token #\.)))
#+end_src

When the header says =HS256= that means =hmac-sha256=.

#+begin_src scheme :noweb-ref test-tutorial
  > (STRING hmac-header)
  "{\"typ\":\"JWT\",\r\n \"alg\":\"HS256\"}"
#+end_src

The RFC gives us a key.

#+begin_src scheme :noweb-ref test-tutorial
  > (def hmac-key "AyM1SysPpbyDfgZld3umj1qzKObwVMkoqQ-EstJQLr_T-1qS0gZH75aKtMN3Yj0iPS4hcgUuTwjAzZr1Z9CAow")
  > (def hmac-key-bytes (BYTES hmac-key))
#+end_src

Now something to sign.

#+begin_src scheme :noweb-ref test-tutorial
  > (def hmac-signing-input
      (string->utf8 (format "~a.~a" hmac-header hmac-payload)))
#+end_src

The way to sign it is, strangely enough, the [[https://cons.io/reference/std/crypto.html#hmac-sha256][hmac-sha256]]
function.

#+begin_src scheme :noweb-ref test-tutorial
  > (def hmac-signing-output (hmac-sha256 hmac-key-bytes hmac-signing-input))
  > (string=? (BASE64URL hmac-signing-output) hmac-signature)
  #t
#+end_src

That's also the validation. There is no public key so getting the same
signature from the same key is exactly what we want.


** Reference Documents
:PROPERTIES:
:CUSTOM_ID: reference-documents
:END:

A number of pointers to get me there:

  - https://wiki.openssl.org/index.php/EVP_Signing_and_Verifying
  - https://ephemeral.cx/2012/06/openssl-rsa-aes-and-c/
  - https://gist.github.com/jusonqiu/6fcfe386f209d46c5f1d

  - https://www.rfc-editor.org/rfc/rfc7518#section-3.3

  And the big one with examples:

  https://www.rfc-editor.org/rfc/rfc7515.html#appendix-A.2


* Reference

The main docs are in [[file:~/src/gerbil-monad/doc/reference/std/crypto.md::Cryptography][the doc tree.]]

* Test File
:PROPERTIES:
:CUSTOM_ID: test-file
:END:

This 


#+begin_src scheme :noweb yes :tangle ../crypto-test.ss
  ;;; -*- Gerbil -*-
  ;;; (C) me at drewc.ca
  ;;; (C) fare at tunes.org
  ;;; :std/crypto unit-tests

  (import :std/test
          :std/iter
          :std/format
          :std/misc/ports
          :std/text/json
          :std/text/base64
          :std/misc/process
          :std/text/hex
          :std/crypto
          :std/make
          :gerbil/compiler)
  (export crypto-test)

  (defsyntax (test-inline stx)
    (syntax-case stx (>)
      ((_ test-case: name rest ...)
       #'(test-case name (test-inline rest ...)))
      ((_ > form > rest ...)
       #'(begin (when std/test#*test-verbose*
  		  (displayln "... "
  			     (with-output-to-string (cut write 'form))))
  		form (test-inline > rest ...)))
      ((_ > test result rest ...)
       #'(begin (check test => 'result) (test-inline rest ...)))
      ((empty ...) #'(begin empty ... #!void))
      (_ #!void)))

  (defsyntax (source-file stx)
    (##container->path (##locat-container (stx-source stx))))
  (def here (path-directory (source-file)))

  (def crypto-test
    (test-suite "test :std/crypto"
      (test-inline
       test-case: "Test Tutorial"
       <<test-tutorial>>)

      #;(test-case "static compilation with libcrypto"
        (def test-dir "/tmp/test.out")
        (def src (path-expand "crypto/digest-test.ss" here))
        (def exe (path-expand "digest-test.exe" test-dir))
        (create-directory* test-dir)
        (compile-module
         src [invoke-gsc: #t optimize: #f verbose: #f debug: #f static: #t
              output-dir: test-dir
              gsc-options: [(include-gambit-sharp)...]])
        (compile-exe
         src [invoke-gsc: #t output-file: exe optimize: #f verbose: #f debug: #f static: #t
              output-dir: test-dir
              gsc-options: [(include-gambit-sharp)...]])
        (check (run-process/batch [exe]) => (void)))))
        
  		 
     


#+end_src
